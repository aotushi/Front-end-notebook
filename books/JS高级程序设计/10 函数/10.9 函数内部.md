## 函数内部

在ECMAScript 5 中，函数内部存在两个特殊的对象：arguments 和this。ECMAScript 6 又新增了new.target 属性

### 10.9.1 arguments

arguments是一个类数组对象，包含调用函数时传入的所有参数**。这个对象只有以function 关键字定义函数（相对于使用箭头语法创建函数）时才会有**。虽然主要用于包含函数参数，但arguments 对象其实还有一个callee 属性，是一个指向arguments 对象所在函数的指针。

来看下面这个经典的阶乘函数：

```javascript
function factorial(num) {
  if (num <= 1) {
    return 1;
  } else {
    return num * factorial(num - 1);
  }
}
```

阶乘函数一般定义成递归调用的，就像上面这个例子一样。只要给函数一个名称，而且这个名称不会变，这样定义就没有问题。但是，这个函数要正确执行就必须保证函数名是factorial，从而导致了紧密耦合。使用arguments.callee 就可以让函数逻辑与函数名解耦：

```javascript
function factorial(num) {
  if (num <= 1) {
    return 1;
  } else {
    return num * arguments.callee(num - 1);
  }
}
```

这个重写之后的factorial()函数已经用arguments.callee 代替了之前硬编码的factorial。这意味着无论函数叫什么名称，都可以引用正确的函数。考虑下面的情况：

```javascript
let trueFactorial = factorial;

factorial = function() {
  return 0;
};

console.log(trueFactorial(5)); //120
console.log(factorial(5)); //0
```

这里，trueFactorial 变量被赋值为factorial，实际上把同一个函数的指针又保存到了另一个位置。然后，factorial 函数又被重写为一个返回0 的函数。如果像factorial()最初的版本那样不使用arguments.callee，那么像上面这样调用trueFactorial()就会返回0。不过，通过将函数与名称解耦，trueFactorial()就可以正确计算阶乘，而factorial()则只能返回0。

### 10.9.2 this

另一个特殊的对象是this，它在标准函数和箭头函数中有不同的行为。

#### 标准函数中的this

在标准函数中，this 引用的是把函数当成方法调用的上下文对象，这时候通常称其为this 值（在网页的全局上下文中调用函数时，this 指向windows）。来看下面的例子：

```javascript
window.color = 'red';
let o = {
  color: 'blue'
};

function sayColor() {
  console.log(this.color);
}

sayColor(); //'red'
o.sayColor = sayColor;
o.sayColor(); //'blue'
```

定义在全局上下文中的函数sayColor()引用了this 对象。这个this 到底引用哪个对象必须到函数被调用时才能确定。因此这个值在代码执行的过程中可能会变。如果在全局上下文中调用sayColor()，这结果会输出"red"，因为this 指向window，而this.color 相当于window.color。而在把sayColor()赋值给o 之后再调用o.sayColor()，this 会指向o，即this.color 相当于o.color，所以会显示"blue"。

#### 箭头函数中的this

**在箭头函数中，this 引用的是定义箭头函数的上下文。**下面的例子演示了这一点。在对sayColor()的两次调用中，this 引用的都是window 对象，因为这个箭头函数是在window 上下文中定义的：

```javascript
window.color = 'red';
```











































