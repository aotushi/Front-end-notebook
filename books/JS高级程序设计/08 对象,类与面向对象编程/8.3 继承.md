## 8.3 继承

### 0.概述(接口继承, 实现继承)

> 继承是面向对象编程中讨论最多的话题。很多面向对象语言都支持两种继承：接口继承和实现继承。
> 前者只继承方法签名，后者继承实际的方法。
>
> 接口继承在ECMAScript 中是不可能的，因为函数没有签名。实现继承是ECMAScript 唯一支持的继承方式，而这主要是通过原型链实现的。



### 8.3.1.原型链

ECMA-262 把原型链定义为ECMAScript 的主要继承方式。其基本思想就是通过原型继承多个引用类型的属性和方法。

**构造函数, 原型和实例的关系**:(!!) 每一个构造函数都有一个原型对象, 原型有个属性指回构造函数, 而实例有一个内部指针指向原型.

如果原型是另一个类型的实例呢?  ？那就意味着这个原型本身有一个内部指针指向另一个原型，相应地另一个原型也有一个指针指向另一个构造函数。这样就在实例和原型之间构造了一条原型链。这就是原型链的基本构想。

> What if the prototype were actually an instance of another type?



实现原型链涉及如下代码模式:

```js
function SuperType() {
  this.property = true;
}

SuperType.prototype.getSuperValue = function() {
  return this.property;
};

function SubType() {
  this.subproperty = false;
}

//继承 SuperType
SubType.prototype = new SuperType();

SubType.prototype.getSubValue = function() {
  return this.subproperty;
}

let instance = new SubType();
console.log(instance.getSuperValue()); //true
```

以上代码定义了两个类型：SuperType 和SubType。这两个类型分别定义了一个属性和一个方法。这两个类型的主要区别是SubType 通过创建SuperType 的实例并将其赋值给自己的原型SubTtype.prototype 实现了对SuperType 的继承。这个赋值重写了SubType 最初的原型，将其替换为SuperType 的实例。这意味着SuperType 实例可以访问的所有属性和方法也会存在于SubType.prototype。这样实现继承之后，代码紧接着又给SubType.prototype，也就是这个SuperType 的实例添加了一个新方法。最后又创建了SubType 的实例并调用了它继承的getSuperValue()方法。



> 这个例子中实现继承的关键，是SubType 没有使用默认原型，而是将其替换成了一个新的对象。这个新的对象恰好是SuperType 的实例。
>
> 这样一来，SubType 的实例不仅能从SuperType 的实例中继承属性和方法，而且还与SuperType 的原型挂上了钩。于是instance（通过内部的[[Prototype]]）指向SubType.prototype，而SubType.prototype（作为SuperType 的实例又通过内部的[[Prototype]]）指向SuperType.prototype。
>
> 注意，getSuperValue()方法还在SuperType.prototype 对象上，而property 属性则在SubType.prototype 上。这是因为getSuperValue()是一个原型方法，而property 是一个实例属性。SubType.prototype 现在是SuperType 的一个实例，因此property才会存储在它上面。还要注意，由于SubType.prototype 的constructor 属性被重写为指向SuperType，所以instance.constructor 也指向SuperType。

原型链扩展了前面描述的原型搜索机制。我们知道，在读取实例上的属性时，首先会在实例上搜索这个属性。如果没找到，则会继承搜索实例的原型。在通过原型链实现继承之后，搜索就可以继承向上，搜索原型的原型。对前面的例子而言，调用instance.getSuperValue()经过了3 步搜索：instance、SubType.prototype 和SuperType.prototype，最后一步才找到这个方法。对属性和方法的搜索会一直持续到原型链的末端。



#### 1.默认原型

。默认情况下，所有引用类型都继承自Object，这也是通过原型链实现的。任何函数的默认原型都是一个Object 的实例，这意味着这个实例有一个内部指针指向Object.prototype。这也是为什么自定义类型能够继承包括toString()、valueOf()在内的所有默
认方法的原因。

![原型链](https://img-blog.csdnimg.cn/20210219115901563.png)



SubType 继承SuperType，而SuperType 继承Object。在调用instance.toString()时，实际上调用的是保存在Object.prototype 上的方法。

#### 2.原型与继承的关系

**原型与实例的关系**(!!)可以通过两种方式来确定。第一种方式是使用**instanceof 操作符**，如果一个实例的原型链中出现过相应的构造函数，则instanceof 返回true

从技术上讲，instance 是Object、SuperType 和SubType 的实例，因为instance 的原型链中包含这些构造函数的原型。结果就是instanceof 对所有这些构造函数都返回true。

```js
console.log(instance instanceof Object); // true
console.log(instance instanceof SuperType); // true
console.log(instance instanceof SubType); // true
```

确定这种关系的第二种方式是使用isPrototypeOf()方法。原型链中的每个原型都可以调用这个方法，如下例所示，只要原型链中包含这个原型，这个方法就返回true：

```js
console.log(Object.prototype.isPrototypeOf(instance)); // true
console.log(SuperType.prototype.isPrototypeOf(instance)); // true
console.log(SubType.prototype.isPrototypeOf(instance)); // true
```



#### 3.关于方法

子类有时候需要覆盖父类的方法，或者增加父类没有的方法。为此，这些方法必须在原型赋值之后再添加到原型上。





























