虽然使用Object 构造函数或对象字面量可以方便地创建对象，但这些方式也有明显不足：<span style="color:blue;">创建具有同样接口的多个对象需要重复编写很多代码。</span>

### 8.2.1 概述

ECMAScript 6 开始正式支持类和继承。ES6 的类旨在完全涵盖之前规范设计的基于原型的继承模式。不过，无论从哪方面看，ES6 的类都仅仅是封装了ES5.1 构造函数加原型继承的语法糖而已。



### 8.2.2 工厂模式

工厂模式是一种众所周知的设计模式，广泛应用于软件工程领域，**用于抽象创建特定对象的过程**。（本书后面还会讨论其他设计模式及其在JavaScript 中的实现。）下面的例子展示了一种按照特定接口创建对象的方式：

```js
function createPerson(name, age, job) {
  let o = new Object();
  o.name = name;
  o.age = age;
  o.job = job;
  o.sayName = function() {
    console.log(this.name);
  };
  return o;
}

let person1 = function createPerson('Nicholas', 29' 'Software Engineer');
let person2 = createPerson("Greg", 27, "Doctor");                                     
```

函数createPerson()接收3 个参数，根据这几个参数构建了一个包含Person 信息的对象。可以用不同的参数多次调用这个函数，每次都会返回包含3 个属性和1 个方法的对象。<span style="color:blue;">**这种工厂模式虽然可以解决创建多个类似对象的问题，但没有解决对象标识问题（即新创建的对象是什么类型）。**</span>

### 8.2.3 构造函数模式

**ECMAScript 中的构造函数是用于创建特定类型对象的**。像Object 和Array 这样的原生构造函数，运行时可以直接在执行环境中使用。当然也可以自定义构造函数，以函数的形式为自己的对象类型定义属性和方法。

比如，前面的例子使用构造函数模式可以这样写：

```js
function Person(name, age, job) {
  this.name = name;
  this.age = age;
  this.job = job;
  this.sayName = function() {console.log(this.name)}
}

let person1 = new Person("Nicholas", 29, "Software Engineer");
let person2 = new Person("Greg", 27, "Doctor");
person1.sayName(); // Nicholas
person2.sayName(); // Greg
```

在这个例子中，Person()构造函数代替了createPerson()工厂函数。实际上，Person()内部的代码跟createPerson()基本是一样的，只是有如下区别。

#### 1.构造函数和工厂函数的比较

* 没有显式地创建对象
* 属性和方法直接赋值给了this
* 没有return

要注意函数名Person 的首字母大写了。按照惯例，构造函数名称的首字母都是要大写的，非构造函数则以小写字母开头。这是从面向对象编程语言那里借鉴的，有助于在ECMAScript 中区分构造函数和普通函数。毕竟ECMAScript 的构造函数就是能创建对象的函数。(非强制)

#### 2.调用构造函数会发生什么?

要创建Person 的实例，应使用new 操作符。以这种方式调用构造函数会执行如下操作。

```js
1.在内存中创建一个新对象
2.这个新对象内部的[[Prototype]]特性被赋值为构造函数的prototype属性
3.构造函数内部的this 被赋值为这个新对象（即this 指向新对象）
4.执行构造函数内部的代码（给新对象添加属性）。
5.如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象。
```









































































