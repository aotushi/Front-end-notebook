虽然使用Object 构造函数或对象字面量可以方便地创建对象，但这些方式也有明显不足：<span style="color:blue;">创建具有同样接口的多个对象需要重复编写很多代码。</span>

### 8.2.1 概述

ECMAScript 6 开始正式支持类和继承。ES6 的类旨在完全涵盖之前规范设计的基于原型的继承模式。不过，无论从哪方面看，ES6 的类都仅仅是封装了ES5.1 构造函数加原型继承的语法糖而已。



### 8.2.2 工厂模式

工厂模式是一种众所周知的设计模式，广泛应用于软件工程领域，**用于抽象创建特定对象的过程**。（本书后面还会讨论其他设计模式及其在JavaScript 中的实现。）下面的例子展示了一种按照特定接口创建对象的方式：

```js
function createPerson(name, age, job) {
  let o = new Object();
  o.name = name;
  o.age = age;
  o.job = job;
  o.sayName = function() {
    console.log(this.name);
  };
  return o;
}

let person1 = function createPerson('Nicholas', 29' 'Software Engineer');
let person2 = createPerson("Greg", 27, "Doctor");                                     
```

函数createPerson()接收3 个参数，根据这几个参数构建了一个包含Person 信息的对象。可以用不同的参数多次调用这个函数，每次都会返回包含3 个属性和1 个方法的对象。<span style="color:blue;">**这种工厂模式虽然可以解决创建多个类似对象的问题，但没有解决对象标识问题（即新创建的对象是什么类型）。**</span>

### 8.2.3 构造函数模式

**ECMAScript 中的构造函数是用于创建特定类型对象的**。像Object 和Array 这样的原生构造函数，运行时可以直接在执行环境中使用。当然也可以自定义构造函数，以函数的形式为自己的对象类型定义属性和方法。

比如，前面的例子使用构造函数模式可以这样写：

```js
function Person(name, age, job) {
  this.name = name;
  this.age = age;
  this.job = job;
  this.sayName = function() {console.log(this.name)}
}

let person1 = new Person("Nicholas", 29, "Software Engineer");
let person2 = new Person("Greg", 27, "Doctor");
person1.sayName(); // Nicholas
person2.sayName(); // Greg
```

在这个例子中，Person()构造函数代替了createPerson()工厂函数。实际上，Person()内部的代码跟createPerson()基本是一样的，只是有如下区别。

#### 1.构造函数和工厂函数的比较

* 没有显式地创建对象
* 属性和方法直接赋值给了this
* 没有return

要注意函数名Person 的首字母大写了。按照惯例，构造函数名称的首字母都是要大写的，非构造函数则以小写字母开头。这是从面向对象编程语言那里借鉴的，有助于在ECMAScript 中区分构造函数和普通函数。毕竟ECMAScript 的构造函数就是能创建对象的函数。(非强制)

#### 2.调用构造函数会发生什么?

要创建Person 的实例，应使用new 操作符。以这种方式调用构造函数会执行如下操作。

```js
1.在内存中创建一个新对象
2.这个新对象内部的[[Prototype]]特性被赋值为构造函数的prototype属性
3.构造函数内部的this 被赋值为这个新对象（即this 指向新对象）
4.执行构造函数内部的代码（给新对象添加属性）。
5.如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象。
```

上一个例子的最后，person1 和person2 分别保存着Person 的不同实例。这两个对象都有一个constructor 属性指向Person，如下所示：

```js
console.log(person1.constructor == Person); //true
console.log(person2.constructor == Person); //true


//这里需要注意一下.开始我以为打印的是实例的隐式原型对象到显式原型对象身上的constructor, 但直接打印person1.__proto__, 效果如下:

{constructor: ƒ}constructor: ƒ 
[[Prototype]]: Objectconstructor
```

#### 3.constructor vs instanceof

**constructor 本来是用于标识对象类型的**。不过，**一般认为instanceof 操作符是确定对象类型更可靠的方式**。前面例子中的每个对象都是Object 的实例，同时也是Person 的实例，如下面调用instanceof 操作符的结果所示：

```js
console.log(person1 instanceof Object); // true
console.log(person1 instanceof Person); // true
console.log(person2 instanceof Object); // true
console.log(person2 instanceof Person); // true
```

**定义自定义构造函数可以确保实例被标识为特定类型，相比于工厂模式，这是一个很大的好处**。在这个例子中，person1 和person2 之所以也被认为是Object 的实例，是因为所有自定义对象都继承自Object（后面再详细讨论这一点）。

构造函数不一定要写成函数声明的形式。赋值给变量的函数表达式也可以表示构造函数：

```js
let Person = function(name, age, job) {
  this.name = name;
  this.age = age;
  this.job = job;
  this.sayName = function() {
    console.log(this.name);
  };
}

let person1 = new Person("Nicholas", 29, "Software Engineer");
let person2 = new Person("Greg", 27, "Doctor");
person1.sayName(); // Nicholas
person2.sayName(); // Greg
console.log(person1 instanceof Object); // true
console.log(person1 instanceof Person); // true
console.log(person2 instanceof Object); // true
console.log(person2 instanceof Person); // true
```

在实例化时，如果不想传参数，那么构造函数后面的括号可加可不加。只要有new 操作符，就可以调用相应的构造函数：

```js
function Person() {
	this.name = "Jake";
	this.sayName = function() {
	console.log(this.name);
	};
}

let person1 = new Person();
let person2 = new Person;

person1.sayName(); // Jake
person2.sayName(); // Jake
console.log(person1 instanceof Object); // true
console.log(person1 instanceof Person); // true
console.log(person2 instanceof Object); // true
console.log(person2 instanceof Person); // true
```



#### 1.构造函数也是函数

**构造函数与普通函数唯一的区别就是调用方式不同**。除此之外，构造函数也是函数。并没有把某个函数定义为构造函数的特殊语法。任何函数只要使用new 操作符调用就是构造函数，而不使用new 操作符调用的函数就是普通函数。比如，前面的例子中定义的Person()可以像下面这样调用：

```js
// 作为构造函数
let person = new Person("Nicholas", 29, "Software Engineer");
person.sayName(); // "Nicholas"

// 作为函数调用
Person("Greg", 27, "Doctor"); // 添加到window 对象
window.sayName(); // "Greg"

// 在另一个对象的作用域中调用
let o = new Object();
Person.call(o, "Kristen", 25, "Nurse");
o.sayName(); // "Kristen"
```

以上案例说明:

1.构造函数调用方式

2.调用一个函数而没有明确设置this值的青岛下(即没有作为对象的方法调用,或者没有使用call()或apply()调用),this始终指向Global对象(在浏览器器中就是window对象). 

3.最后展示的是通过call()(或apply())调用函数,同时将特定对象指定未作用域.



#### 2.构造函数的问题

<span style="color:blue;">**构造函数的主要问题在于，其定义的方法会在每个实例上都创建一遍。**</span>因此对前面的例子而言，person1 和person2 都有名为sayName()的方法，但这两个方
法不是同一个Function 实例。我们知道，ECMAScript 中的函数是对象，因此每次定义函数时，都会初始化一个对象。逻辑上讲，这个构造函数实际上是这样的：

```js
function Person(name, age, job){
	this.name = name;
	this.age = age;
	this.job = job;
	this.sayName = new Function("console.log(this.name)"); // 逻辑等价
}
```

这样理解这个构造函数可以更清楚地知道，每个Person 实例都会有自己的Function 实例用于显示name 属性。当然了，**以这种方式创建函数会带来不同的作用域链和标识符解析**。但创建新Function实例的机制是一样的。因此不同实例上的函数虽然同名却不相等，如下所示：

```js
console.log(person1.sayName == person2.sayName); //false
```

因为都是做一样的事，所以没必要定义两个不同的Function 实例。况且，**this 对象可以把函数与对象的绑定推迟到运行时。要解决这个问题，可以把函数定义转移到构造函数外部：**

```js
function Person(name, age, job){
	this.name = name;
	this.age = age;
	this.job = job;
	this.sayName = sayName;
}
function sayName() {
	console.log(this.name);
}

let person1 = new Person("Nicholas", 29, "Software Engineer");
let person2 = new Person("Greg", 27, "Doctor");
person1.sayName(); // Nicholas
person2.sayName(); // Greg
```

**外部定义函数的问题及解决:**

在这里，sayName()被定义在了构造函数外部。在构造函数内部，sayName 属性等于全局sayName()函数。因为这一次sayName 属性中包含的只是一个指向外部函数的指针，所以person1 和person2共享了定义在全局作用域上的sayName()函数。

这样虽**然解决了相同逻辑的函数重复定义的问题，但全局作用域也因此被搞乱了**，因为那个函数实际上只能在一个对象上调用。如果这个对象需要多个方法，那么就要在全局作用域中定义多个函数。这会导致自定义类型引用的代码不能很好地聚集一起。这个新问题可以通过**原型模式**来解决。



### 8.2.4 原型模式

每个函数都会创建一个prototype 属性，这个属性是一个对象，包含应该由特定引用类型的实例共享的属性和方法。实际上，这个对象就是通过调用构造函数创建的对象的原型。使用原型对象的好处是，在它上面定义的属性和方法可以被对象实例共享。原来在构造函数中直接赋给对象实例的值，可以直接赋值给它们的原型，如下所示：

> Each function is created with a prototype property, which is an object containing properties and methdos that should be available to instances of a particular reference type.

```js
function Person() {}

Person.prototype.name = 'Nicholas';
Person.prototype.age = 29;
Person.prototype.job = 'Software Engineer';
Person.prototype.sayName = function() {console.log(this.name);};


```

























































