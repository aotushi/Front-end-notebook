> ECMA-262 将对象定义为一组<span style="color:blue;">**属性的无序集合**</span>。严格来说，这意味着对象就是一组没有特定顺序的
> 值。
>
> 对象的每个属性或方法都由一个名称来标识，这个名称映射到一个值。正因为如此（以及其他还未讨论的原因），可以把ECMAScript 的对象想象成一张散列表，其中的内容就是一组名/值对，值可以是数据或者函数。

## 8.1 理解对象

创建对象的2种方法: 构造函数和对象字面量

```js
//构造函数
let person = new Object();
person.name = 'Nicholas';
person.age = 29;
person.job = 'Software Engineer';
person.sayName = function() {console.log(this.name);}
//对象字面量
let person = {
	name: "Nicholas",
	age: 29,
	job: "Software Engineer",
	sayName() {
		console.log(this.name);
	}
};
```



### 8.1.1 属性的类型

ECMA-262 使用一些内部特性来描述属性的特征。这些特性是由为JavaScript 实现引擎的规范定义的。因此，开发者不能在JavaScript 中直接访问这些特性。为了将某个特性**标识为内部特性**，规范会**用两个中括号**把特性的名称括起来，比如[[Enumerable]]。

**属性分两种: 数据属性和访问器属性**

#### 1. 数据属性

数据属性包含一个保存数据值的位置。值会从这个位置读取，也会写入到这个位置。数据属性有4个特性描述它们的行为。

| 数据属性的4个特性 | 定义                                                         |
| ----------------- | ------------------------------------------------------------ |
| [[Configurable]]  | 标识属性:<br />是否可以通过delete删除并重新定义<br />是否可以通过修改它的特性<br />是否可以把它改为访问器属性<br />默认情况下所有直接定义在对象上的属性的这个特<br/>性都是true， |
| [[Enumerable]]    | 属性是否可以通过for-in循环返回.<br />默认,所有直接定义在对象上的属性的这个特性都是true |
| [[Writable]]      | 属性的值是否可以被修改.<br />默认,所有直接定义在对象上的属性的这个特性都是true |
| [[Value]]         | 包含属性实际的值.<br />这就是前面提到的那个读取和写入属性值的位置。这个特性<br/>的默认值为undefined。 |

**要修改属性的默认特性, 必须使用`Object.defineProperty()`**方法. 这个方法接收3 个参数：要给其添加属性的对象、属性的名称和一个描述符对象,并返回这个对象.    最后一个参数，即**描述符对象上的属性可以包含：configurable、enumerable、writable 和value，跟相关特性的名称一一对应**。根据要修改的特性，**可以设置其中一个或多个值**。比如：

```js
//接收3个参数: 对象,属性名, 描述符对象

let person = {};
Object.defineProperty(person, "name", {
	writable: false,
	value: "Nicholas"
});

console.log(person.name); // "Nicholas"
person.name = "Greg";
console.log(person.name); // "Nicholas"

//在非严格模式下尝试给这个属性重新赋值会被忽略。在严格模式下，尝试修改只读属性的值会抛出错误。
```

类似的规则也适用于创建不可配置的属性, 一个属性被定义为不可配置之后，就不能再变回可配置的了.

```js
let person = {};
Object.defineProperty(person, "name", {
 configurable: false,
 value: "Nicholas"
});
console.log(person.name); // "Nicholas"
delete person.name;
console.log(person.name); // "Nicholas"
```

再次调用Object.defineProperty()并修改任何非writable 属性会导致错误

```js
let person = {};
Object.defineProperty(person, "name", {
	configurable: false,
	value: "Nicholas"
});
// 抛出错误
Object.defineProperty(person, "name", {
configurable: true,
value: "Nicholas"
});
```

虽然可以对同一个属性多次调用Object.defineProperty()，但在把configurable 设置为false 之后就会受限制了。在调用Object.defineProperty()时，configurable、enumerable 和writable 的值如果不指定，则都默认为false。

#### 2. 访问器属性

> **访问器属性不包含数据值**。相反，它们包含一个获取（getter）函数和一个设置（setter）函数，不
> 过这两个函数不是必需的。
>
> **在读取访问器属性时，会调用获取函数**，这个函数的责任就是返回一个有效的值。
>
> **在写入访问器属性时，会调用设置函数并传入新值**，这个函数必须决定对数据做出什么修改。
>
> 访问器属性有4 个特性描述它们的行为。

| 访问器属性4特性  | 含义及作用                                                   |
| ---------------- | ------------------------------------------------------------ |
| [[Configurable]] | 是否可以通过delete删除并重新定义<br />是否可以修改它的特性<br />是否可以把它改为数据属性<br />默认,所有直接定义在对象身上的属性的这个特性都是true |
| [[Enumerable]]   | 标识属性是否可以通过for-in循环返回<br />默认, 所有直接定义在对象身上的属性的这个特性都是true |
| [[Get]]          | 获取函数<br />在读取属性时调用. 默认值为undefined            |
| [[Set]]          | 设计函数<br />在写入属性时调用. 默认值是undefined            |

**访问器属性是不能直接定义的，必须使用Object.defineProperty()**

// 定义一个对象，包含伪私有成员year_和公共成员edition

```js
let book = {
year_: 2017,
edition: 1
}

Object.defineProperty(book, 'year', {
  get() {
    return this.year_;
  },
  set() {
    if(newValue>2017) {
      this.year_ = newValue;
      this.edition += newValue - 2017;
    }
  }
})
```

year_中的下划线常用来表示该属性并不希望在对象方法的外部被访问。

获取函数和设置函数不一定都要定义。只定义获取函数意味着属性是只读的，尝试修改属性会被忽略。在严格模式下，尝试写入只定义了获取函数的属性会抛出错误。类似地，只有一个设置函数的属性是不能读取的，非严格模式下读取会返回undefined，严格模式下会抛出错误。







### 8.1.2 定义多个属性

> ECMAScript 提供了**Object.define-Properties()**方法。这个方法可以通过多个描述符一次性定义多个属性。
>
> 它接收两个参数：要为之**添加或修改属性**的对象和另一个描述符对象，其属性与要添加或修改的属性一一对应

```js
let book = {};
Object.definedProperties(book, {
  year_: {value: 2017},
  edition: {value: 1},
  year: {
    get() {return this.year_;},
    set() {if (newVal > 2017) {
      this.year_ = newVal;
      this.edition += newValue - 2017;
    }}
  },
})
```

这段代码在book 对象上定义了两个数据属性year_和edition，还有一个访问器属性year。
最终的对象跟上一节示例中的一样。唯一的区别是所有属性都是同时定义的，并且数据属性的configurable、enumerable 和writable 特性值都是false。



### 8.1.3 读取属性的特性

**Object.getOwnPropertyDescriptor()**

> 使用**Object.getOwnPropertyDescriptor()**方法可以取得指定属性的属性描述符.
>
> 这个方法**接收两个参数**：属性所在的对象和要取得其描述符的属性名。
>
> **返回值**是一个对象，
>
>  对于访问器属性包含configurable、enumerable、get 和set 属性，
>
>  对于数据属性包含configurable、enumerable、writable 和value 属性。

```js
let book = {};
Object.defineProperties(book, {
	year_: {
	value: 2017
},
	edition: {
	value: 1
},
year: {
	get: function() {
	return this.year_;
},
set: function(newValue){
	if (newValue > 2017) {
	this.year_ = newValue;
	this.edition += newValue - 2017;
	}
}
}
});

let descriptor = Object.getOwnPropertyDescriptor(book, "year_");
console.log(descriptor.value); // 2017
console.log(descriptor.configurable); // false
console.log(typeof descriptor.get); // "undefined"

let descriptor = Object.getOwnPropertyDescriptor(book, "year");
console.log(descriptor.value); // undefined
console.log(descriptor.enumerable); // false
console.log(typeof descriptor.get); // "function"
```

**Object.getOwnPropertyDescriptors()**

ECMAScript 2017 新增了Object.getOwnPropertyDescriptors()静态方法。这个方法实际上会在每个自有属性上调用Object.getOwnPropertyDescriptor()并在一个新对象中返回它们。对于前面的例子，使用这个静态方法会返回如下对象：

```js
let book = {};
Object.defineProperties(book, {
year_: {
value: 2017
},
edition: {
value: 1
},
year: {
get: function() {
return this.year_;
},
set: function(newValue){
if (newValue > 2017) {
this.year_ = newValue;
this.edition += newValue - 2017;
}
}
}
});
console.log(Object.getOwnPropertyDescriptors(book));
// {
// edition: {
// configurable: false,
// enumerable: false,
// value: 1,
// writable: false
// },
// year: {
// configurable: false,
// enumerable: false,
// get: f(),
// set: f(newValue),
// },
// year_: {
// configurable: false,
// enumerable: false,
// value: 2017,
// writable: false
// }
// }
```



### 8.1.4 合并对象

**合并对象**,就是把源对象所有的本地属性一起复制到目标对象上。有时候这种操作也被称为**“混入”（mixin）**，因为目标对象通过混入源对象的属性得到了增强.

#### Object.assign()

这个方法接收一个目标对象和一个或多个源对象作为参数，然后将每个源对象中**可枚举（Object.propertyIsEnumerable()返回true）和自有（Object.hasOwnProperty()返回true）属性**复制到目标对象。以字符串和符号为键的属性会被复制。

<span style="color:blue;">对每个符合条件的属性，这个方法会使用源对象上的[[Get]]取得属性的值，然后使用目标对象上的[[Set]]设置属性的值。</span>

```js
let dest, src, result;

//简单复制
dest = {};
src = {id: 'src'};

result = Object.assign(dest, src);

//Object.assign修改目标对象, 也会返回修改后的目标对象
console.log(dest === result);  //true
console.log(dest !== src);     //true
console.log(result);					 // {id: src}
console.log(dest);						 // {id: src}


```





























































