> ECMA-262 将对象定义为一组<span style="color:blue;">**属性的无序集合**</span>。严格来说，这意味着对象就是一组没有特定顺序的
> 值。
>
> 对象的每个属性或方法都由一个名称来标识，这个名称映射到一个值。正因为如此（以及其他还未讨论的原因），可以把ECMAScript 的对象想象成一张散列表，其中的内容就是一组名/值对，值可以是数据或者函数。

## 8.1 理解对象

创建对象的2种方法: 构造函数和对象字面量

```js
//构造函数
let person = new Object();
person.name = 'Nicholas';
person.age = 29;
person.job = 'Software Engineer';
person.sayName = function() {console.log(this.name);}
//对象字面量
let person = {
	name: "Nicholas",
	age: 29,
	job: "Software Engineer",
	sayName() {
		console.log(this.name);
	}
};
```



### 8.1.1 属性的类型

ECMA-262 使用一些内部特性来描述属性的特征。这些特性是由为JavaScript 实现引擎的规范定义的。因此，开发者不能在JavaScript 中直接访问这些特性。为了将某个特性**标识为内部特性**，规范会**用两个中括号**把特性的名称括起来，比如[[Enumerable]]。

**属性分两种: 数据属性和访问器属性**

#### 1. 数据属性

数据属性包含一个保存数据值的位置。值会从这个位置读取，也会写入到这个位置。数据属性有4个特性描述它们的行为。

| 数据属性的4个特性 | 定义                                                         |
| ----------------- | ------------------------------------------------------------ |
| [[Configurable]]  | 标识属性:<br />是否可以通过delete删除并重新定义<br />是否可以通过修改它的特性<br />是否可以把它改为访问器属性<br />默认情况下所有直接定义在对象上的属性的这个特<br/>性都是true， |
| [[Enumerable]]    | 属性是否可以通过for-in循环返回.<br />默认,所有直接定义在对象上的属性的这个特性都是true |
| [[Writable]]      | 属性的值是否可以被修改.<br />默认,所有直接定义在对象上的属性的这个特性都是true |
| [[Value]]         | 包含属性实际的值.<br />这就是前面提到的那个读取和写入属性值的位置。这个特性<br/>的默认值为undefined。 |

**要修改属性的默认特性, 必须使用`Object.defineProperty()`**方法. 这个方法接收3 个参数：要给其添加属性的对象、属性的名称和一个描述符对象,并返回这个对象.    最后一个参数，即**描述符对象上的属性可以包含：configurable、enumerable、writable 和value，跟相关特性的名称一一对应**。根据要修改的特性，**可以设置其中一个或多个值**。比如：

```js
//接收3个参数: 对象,属性名, 描述符对象

let person = {};
Object.defineProperty(person, "name", {
	writable: false,
	value: "Nicholas"
});

console.log(person.name); // "Nicholas"
person.name = "Greg";
console.log(person.name); // "Nicholas"

//在非严格模式下尝试给这个属性重新赋值会被忽略。在严格模式下，尝试修改只读属性的值会抛出错误。
```

类似的规则也适用于创建不可配置的属性, 一个属性被定义为不可配置之后，就不能再变回可配置的了.

```js
let person = {};
Object.defineProperty(person, "name", {
 configurable: false,
 value: "Nicholas"
});
console.log(person.name); // "Nicholas"
delete person.name;
console.log(person.name); // "Nicholas"
```

再次调用Object.defineProperty()并修改任何非writable 属性会导致错误

```js
let person = {};
Object.defineProperty(person, "name", {
	configurable: false,
	value: "Nicholas"
});
// 抛出错误
Object.defineProperty(person, "name", {
configurable: true,
value: "Nicholas"
});
```

虽然可以对同一个属性多次调用Object.defineProperty()，但在把configurable 设置为false 之后就会受限制了。在调用Object.defineProperty()时，configurable、enumerable 和writable 的值如果不指定，则都默认为false。

#### 2. 访问器属性

> **访问器属性不包含数据值**。相反，它们包含一个获取（getter）函数和一个设置（setter）函数，不
> 过这两个函数不是必需的。
>
> **在读取访问器属性时，会调用获取函数**，这个函数的责任就是返回一个有效的值。
>
> **在写入访问器属性时，会调用设置函数并传入新值**，这个函数必须决定对数据做出什么修改。
>
> 访问器属性有4 个特性描述它们的行为。

| 访问器属性4特性  | 含义及作用                                                   |
| ---------------- | ------------------------------------------------------------ |
| [[Configurable]] | 是否可以通过delete删除并重新定义<br />是否可以修改它的特性<br />是否可以把它改为数据属性<br />默认,所有直接定义在对象身上的属性的这个特性都是true |
| [[Enumerable]]   | 标识属性是否可以通过for-in循环返回<br />默认, 所有直接定义在对象身上的属性的这个特性都是true |
| [[Get]]          | 获取函数<br />在读取属性时调用. 默认值为undefined            |
| [[Set]]          | 设计函数<br />在写入属性时调用. 默认值是undefined            |

**访问器属性是不能直接定义的，必须使用Object.defineProperty()**











### 8.1.2 定义多个属性







































































